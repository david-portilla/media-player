{"id":"ejercicios/generators.html","dependencies":[{"name":"/Users/david/dportilla/learning JS/Media-player-plugin/package.json","includedInParent":true,"mtime":1586459586990}],"generated":{"html":"<html>\n  <head>\n    <title>Generators</title>\n  </head>\n\n  <body>\n    <a href=\"/ejercicios/\">Go back</a>\n    <p><em>Abre la consola</em></p>\n\n    <script>var _marked = /*#__PURE__*/regeneratorRuntime.mark(simpleGenerator),\n    _marked2 = /*#__PURE__*/regeneratorRuntime.mark(idMaker),\n    _marked3 = /*#__PURE__*/regeneratorRuntime.mark(idMakerWithReset),\n    _marked4 = /*#__PURE__*/regeneratorRuntime.mark(fibonacci);\n\n// Los generadores son funciones de las que se puede salir y volver a entrar.\n// Su contexto (asociación de variables) será conservado entre las reentradas.\n// Cada vez que llamamos next, la ejecución del generador va a continuar hasta el proximo yield\nfunction simpleGenerator() {\n  return regeneratorRuntime.wrap(function simpleGenerator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          console.log('GENERATOR START');\n          _context.next = 3;\n          return 1;\n\n        case 3:\n          _context.next = 5;\n          return 2;\n\n        case 5:\n          _context.next = 7;\n          return 3;\n\n        case 7:\n          console.log('GENERATOR END');\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n} // const gen = simpleGenerator();\n// Podemos hacer generadores infinitos.\n\n\nfunction idMaker() {\n  var id;\n  return regeneratorRuntime.wrap(function idMaker$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          id = 1;\n\n        case 1:\n          if (!true) {\n            _context2.next = 7;\n            break;\n          }\n\n          _context2.next = 4;\n          return id;\n\n        case 4:\n          id = id + 1;\n          _context2.next = 1;\n          break;\n\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n} // Cuando llamamos next también podemos pasar valores que la función recibe.\n\n\nfunction idMakerWithReset() {\n  var id, reset;\n  return regeneratorRuntime.wrap(function idMakerWithReset$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          id = 1;\n\n        case 1:\n          if (!true) {\n            _context3.next = 8;\n            break;\n          }\n\n          _context3.next = 4;\n          return id;\n\n        case 4:\n          reset = _context3.sent;\n\n          if (reset) {\n            id = 1;\n          } else {\n            id = id + 1;\n          }\n\n          _context3.next = 1;\n          break;\n\n        case 8:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n} // Ahora hagamos un ejemplo un poco más complejo: la secuencia fibonacci\n\n\nfunction fibonacci() {\n  var a, b, nextNumber;\n  return regeneratorRuntime.wrap(function fibonacci$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          a = 1;\n          b = 1;\n\n        case 2:\n          if (!true) {\n            _context4.next = 10;\n            break;\n          }\n\n          nextNumber = a + b;\n          a = b;\n          b = nextNumber;\n          _context4.next = 8;\n          return nextNumber;\n\n        case 8:\n          _context4.next = 2;\n          break;\n\n        case 10:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n}</script>\n  </body>\n</html>\n"},"sourceMaps":null,"error":null,"hash":"ebb5d5c138235e65396695815e4119cb","cacheData":{"env":{}}}